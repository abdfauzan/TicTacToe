{"ast":null,"code":"export const getAIMove = (board, difficulty) => {\n  const boardSize = board.length;\n  const emptyCells = [];\n\n  // Find all empty cells\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      if (board[i][j] === \"\") emptyCells.push({\n        row: i,\n        col: j\n      });\n    }\n  }\n  if (emptyCells.length === 0) return null; // No moves available\n\n  if (difficulty === \"easy\") {\n    return emptyCells[Math.floor(Math.random() * emptyCells.length)];\n  }\n  if (difficulty === \"medium\") {\n    if (Math.random() < 0.5) return emptyCells[Math.floor(Math.random() * emptyCells.length)];\n    return findBestMove(board, \"O\") || emptyCells[0];\n  }\n  if (difficulty === \"hard\") {\n    return findBestMove(board, \"O\") || emptyCells[0];\n  }\n  return findBestMove(board, \"O\");\n};\nconst findBestMove = (board, player) => {\n  const opponent = player === \"X\" ? \"O\" : \"X\";\n  const boardSize = board.length;\n\n  // Check if we can win in one move\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      if (board[i][j] === \"\") {\n        board[i][j] = player;\n        if (calculateWinner(board) === player) {\n          board[i][j] = \"\"; // Undo move\n          return {\n            row: i,\n            col: j\n          };\n        }\n        board[i][j] = \"\"; // Undo move\n      }\n    }\n  }\n\n  // Check if we need to block the opponent from winning\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      if (board[i][j] === \"\") {\n        board[i][j] = opponent;\n        if (calculateWinner(board) === opponent) {\n          board[i][j] = \"\"; // Undo move\n          return {\n            row: i,\n            col: j\n          };\n        }\n        board[i][j] = \"\"; // Undo move\n      }\n    }\n  }\n\n  // If no immediate win or block, pick the first available cell\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      if (board[i][j] === \"\") {\n        return {\n          row: i,\n          col: j\n        };\n      }\n    }\n  }\n  return null;\n};\nexport const calculateWinner = board => {\n  const boardSize = board.length;\n\n  // Check rows for a winner\n  for (let row = 0; row < boardSize; row++) {\n    if (board[row].every(cell => cell === board[row][0] && cell !== \"\")) {\n      return board[row][0];\n    }\n  }\n\n  // Check columns for a winner\n  for (let col = 0; col < boardSize; col++) {\n    if (board.every(row => row[col] === board[0][col] && row[col] !== \"\")) {\n      return board[0][col];\n    }\n  }\n\n  // Check main diagonal for a winner\n  if (board.every((row, idx) => row[idx] === board[0][0] && row[idx] !== \"\")) {\n    return board[0][0];\n  }\n\n  // Check anti-diagonal for a winner\n  if (board.every((row, idx) => row[boardSize - idx - 1] === board[0][boardSize - 1] && row[boardSize - idx - 1] !== \"\")) {\n    return board[0][boardSize - 1];\n  }\n\n  // No winner found\n  return null;\n};","map":{"version":3,"names":["getAIMove","board","difficulty","boardSize","length","emptyCells","i","j","push","row","col","Math","floor","random","findBestMove","player","opponent","calculateWinner","every","cell","idx"],"sources":["C:/Users/mfauz/Documents/github2/TicTacToe/frontend/src/ai/ai.ts"],"sourcesContent":["export const getAIMove = (\n  board: string[][],\n  difficulty: string,\n): { row: number; col: number } | null => {\n  const boardSize = board.length;\n  const emptyCells: { row: number; col: number }[] = [];\n\n  // Find all empty cells\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      if (board[i][j] === \"\") emptyCells.push({ row: i, col: j });\n    }\n  }\n\n  if (emptyCells.length === 0) return null; // No moves available\n\n  if (difficulty === \"easy\") {\n    return emptyCells[Math.floor(Math.random() * emptyCells.length)];\n  }\n\n  if (difficulty === \"medium\") {\n    if (Math.random() < 0.5)\n      return emptyCells[Math.floor(Math.random() * emptyCells.length)];\n    return findBestMove(board, \"O\") || emptyCells[0];\n  }\n\n  if (difficulty === \"hard\") {\n    return findBestMove(board, \"O\") || emptyCells[0];\n  }\n\n  return findBestMove(board, \"O\");\n};\n\nconst findBestMove = (\n  board: string[][],\n  player: \"X\" | \"O\",\n): { row: number; col: number } | null => {\n  const opponent = player === \"X\" ? \"O\" : \"X\";\n  const boardSize = board.length;\n\n  // Check if we can win in one move\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      if (board[i][j] === \"\") {\n        board[i][j] = player;\n        if (calculateWinner(board) === player) {\n          board[i][j] = \"\"; // Undo move\n          return { row: i, col: j };\n        }\n        board[i][j] = \"\"; // Undo move\n      }\n    }\n  }\n\n  // Check if we need to block the opponent from winning\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      if (board[i][j] === \"\") {\n        board[i][j] = opponent;\n        if (calculateWinner(board) === opponent) {\n          board[i][j] = \"\"; // Undo move\n          return { row: i, col: j };\n        }\n        board[i][j] = \"\"; // Undo move\n      }\n    }\n  }\n\n  // If no immediate win or block, pick the first available cell\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      if (board[i][j] === \"\") {\n        return { row: i, col: j };\n      }\n    }\n  }\n\n  return null;\n};\n\nexport const calculateWinner = (board: string[][]): string | null => {\n  const boardSize = board.length;\n\n  // Check rows for a winner\n  for (let row = 0; row < boardSize; row++) {\n    if (board[row].every((cell) => cell === board[row][0] && cell !== \"\")) {\n      return board[row][0];\n    }\n  }\n\n  // Check columns for a winner\n  for (let col = 0; col < boardSize; col++) {\n    if (board.every((row) => row[col] === board[0][col] && row[col] !== \"\")) {\n      return board[0][col];\n    }\n  }\n\n  // Check main diagonal for a winner\n  if (board.every((row, idx) => row[idx] === board[0][0] && row[idx] !== \"\")) {\n    return board[0][0];\n  }\n\n  // Check anti-diagonal for a winner\n  if (\n    board.every(\n      (row, idx) =>\n        row[boardSize - idx - 1] === board[0][boardSize - 1] &&\n        row[boardSize - idx - 1] !== \"\",\n    )\n  ) {\n    return board[0][boardSize - 1];\n  }\n\n  // No winner found\n  return null;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}