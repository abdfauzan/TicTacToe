{"ast":null,"code":"export const getAIMove=(board,difficulty)=>{const boardSize=board.length;const emptyCells=[];// Find all empty cells\nfor(let i=0;i<boardSize;i++){for(let j=0;j<boardSize;j++){if(board[i][j]===\"\")emptyCells.push({row:i,col:j});}}if(emptyCells.length===0)return null;// No moves available\nif(difficulty===\"easy\"){return emptyCells[Math.floor(Math.random()*emptyCells.length)];}if(difficulty===\"medium\"){if(Math.random()<0.5)return emptyCells[Math.floor(Math.random()*emptyCells.length)];return findBestMove(board,\"O\")||emptyCells[0];}if(difficulty===\"hard\"){return findBestMove(board,\"O\")||emptyCells[0];}// Impossible: Perfect AI\nreturn findBestMove(board,\"O\");};const findBestMove=(board,player)=>{const opponent=player===\"X\"?\"O\":\"X\";const boardSize=board.length;// Check if we can win in one move\nfor(let i=0;i<boardSize;i++){for(let j=0;j<boardSize;j++){if(board[i][j]===\"\"){board[i][j]=player;if(calculateWinner(board)===player){board[i][j]=\"\";// Undo move\nreturn{row:i,col:j};}board[i][j]=\"\";// Undo move\n}}}// Check if we need to block the opponent from winning\nfor(let i=0;i<boardSize;i++){for(let j=0;j<boardSize;j++){if(board[i][j]===\"\"){board[i][j]=opponent;if(calculateWinner(board)===opponent){board[i][j]=\"\";// Undo move\nreturn{row:i,col:j};}board[i][j]=\"\";// Undo move\n}}}// If no immediate win or block, pick the first available cell\nfor(let i=0;i<boardSize;i++){for(let j=0;j<boardSize;j++){if(board[i][j]===\"\"){return{row:i,col:j};}}}return null;};export const calculateWinner=board=>{const boardSize=board.length;// Check rows for a winner\nfor(let row=0;row<boardSize;row++){if(board[row].every(cell=>cell===board[row][0]&&cell!==\"\")){return board[row][0];}}// Check columns for a winner\nfor(let col=0;col<boardSize;col++){if(board.every(row=>row[col]===board[0][col]&&row[col]!==\"\")){return board[0][col];}}// Check main diagonal for a winner\nif(board.every((row,idx)=>row[idx]===board[0][0]&&row[idx]!==\"\")){return board[0][0];}// Check anti-diagonal for a winner\nif(board.every((row,idx)=>row[boardSize-idx-1]===board[0][boardSize-1]&&row[boardSize-idx-1]!==\"\")){return board[0][boardSize-1];}// No winner found\nreturn null;};","map":{"version":3,"names":["getAIMove","board","difficulty","boardSize","length","emptyCells","i","j","push","row","col","Math","floor","random","findBestMove","player","opponent","calculateWinner","every","cell","idx"],"sources":["C:/Users/mfauz/Documents/TicTacToe/frontend/src/utils/ai.ts"],"sourcesContent":["export const getAIMove = (\n  board: string[][],\n  difficulty: \"easy\" | \"medium\" | \"hard\" | \"impossible\",\n): { row: number; col: number } | null => {\n  const boardSize = board.length;\n  const emptyCells: { row: number; col: number }[] = [];\n\n  // Find all empty cells\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      if (board[i][j] === \"\") emptyCells.push({ row: i, col: j });\n    }\n  }\n\n  if (emptyCells.length === 0) return null; // No moves available\n\n  if (difficulty === \"easy\") {\n    return emptyCells[Math.floor(Math.random() * emptyCells.length)];\n  }\n\n  if (difficulty === \"medium\") {\n    if (Math.random() < 0.5)\n      return emptyCells[Math.floor(Math.random() * emptyCells.length)];\n    return findBestMove(board, \"O\") || emptyCells[0];\n  }\n\n  if (difficulty === \"hard\") {\n    return findBestMove(board, \"O\") || emptyCells[0];\n  }\n\n  // Impossible: Perfect AI\n  return findBestMove(board, \"O\");\n};\n\nconst findBestMove = (\n  board: string[][],\n  player: \"X\" | \"O\",\n): { row: number; col: number } | null => {\n  const opponent = player === \"X\" ? \"O\" : \"X\";\n  const boardSize = board.length;\n\n  // Check if we can win in one move\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      if (board[i][j] === \"\") {\n        board[i][j] = player;\n        if (calculateWinner(board) === player) {\n          board[i][j] = \"\"; // Undo move\n          return { row: i, col: j };\n        }\n        board[i][j] = \"\"; // Undo move\n      }\n    }\n  }\n\n  // Check if we need to block the opponent from winning\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      if (board[i][j] === \"\") {\n        board[i][j] = opponent;\n        if (calculateWinner(board) === opponent) {\n          board[i][j] = \"\"; // Undo move\n          return { row: i, col: j };\n        }\n        board[i][j] = \"\"; // Undo move\n      }\n    }\n  }\n\n  // If no immediate win or block, pick the first available cell\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      if (board[i][j] === \"\") {\n        return { row: i, col: j };\n      }\n    }\n  }\n\n  return null;\n};\n\nexport const calculateWinner = (board: string[][]): string | null => {\n  const boardSize = board.length;\n\n  // Check rows for a winner\n  for (let row = 0; row < boardSize; row++) {\n    if (board[row].every((cell) => cell === board[row][0] && cell !== \"\")) {\n      return board[row][0];\n    }\n  }\n\n  // Check columns for a winner\n  for (let col = 0; col < boardSize; col++) {\n    if (board.every((row) => row[col] === board[0][col] && row[col] !== \"\")) {\n      return board[0][col];\n    }\n  }\n\n  // Check main diagonal for a winner\n  if (board.every((row, idx) => row[idx] === board[0][0] && row[idx] !== \"\")) {\n    return board[0][0];\n  }\n\n  // Check anti-diagonal for a winner\n  if (\n    board.every(\n      (row, idx) =>\n        row[boardSize - idx - 1] === board[0][boardSize - 1] &&\n        row[boardSize - idx - 1] !== \"\",\n    )\n  ) {\n    return board[0][boardSize - 1];\n  }\n\n  // No winner found\n  return null;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}